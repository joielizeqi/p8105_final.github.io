---
title: "Cumulative impact of various factors on dog bite incidents"
output:
  html_document:
    code_folding: hide
    always_allow_html: true
    toc: true
    toc_float: true
---
```{r, message = FALSE, warning = FALSE, include=FALSE}
library(tidyverse)
library(knitr)
library(rvest)
library(broom)
library(dplyr)
library(purrr)
library(ggplot2)
library(plotly)
library(readxl)
library(reshape2)
library(akima)
library(wordcloud)
library(tm)
```

```{r, message = FALSE, include=FALSE}
# NYC zip code
url = "https://p8105.com/data/zip_codes.html"
ny_zip_codes = read_html(url) |>
  html_table() |> 
  data.frame() |> 
  janitor::clean_names() |> 
  mutate(
    borough = factor(
      county,
      levels=c("Bronx","Kings","New York", "Queens","Richmond"),
      labels=c("Bronx","Brooklyn","Manhattan","Queens",
 "Staten Island"))) 

valid_zipcodes = pull(ny_zip_codes, zip_code)

# Dog bite 
dog_bites_df = read_csv("data/Dog_Bites_Data.csv", na = c("NA", "", ".")) |> 
  janitor::clean_names() |> 
  rename_with(~ gsub("^x", "", .))


dog_bites_clean = dog_bites_df |> 
  mutate(date_of_bite = as.Date(date_of_bite, format = "%B %d %Y")) |> 
  mutate(year = format(date_of_bite, "%Y"),
         month = format(date_of_bite, "%m"),
         day = format(date_of_bite, "%d")) |> 
  mutate(year = as.factor(as.numeric(year)),
         month = factor(as.numeric(month), levels = 1:12),
         day = as.factor(as.numeric(day))
         ) |> 
  mutate(breed = str_to_lower(breed)) |> 
  mutate(breed = ifelse(grepl("mix|mxied|cross|\\s[xX]|-X|/|&|COLLILE,|yorkie poo|yorkie chon|yorkie-poo|yorkipoo|boxer beagle|shi-po|Doberman And Labrador", breed, ignore.case = TRUE), "Mixed", breed)) |> 
  mutate(breed = ifelse(grepl("bull", breed, ignore.case = TRUE), "Bull", breed)) |> 
  mutate(breed = ifelse(grepl("know|KOW|unsure|not given|certain|not sure|unc", breed, ignore.case = TRUE), "Unknown", breed)) |> 
  mutate(breed = ifelse(grepl("poo", breed, ignore.case = TRUE), "Poodle", breed)) |> 
  mutate(breed = ifelse(grepl("vizsla", breed, ignore.case = TRUE), "Vizsla", breed)) |> 
  mutate(breed = ifelse(grepl("shepher|sheherd|shepard|sheep|shpherd|sheperd", breed, ignore.case = TRUE), "Shepherd", breed)) |> 
  mutate(breed = ifelse(grepl("husky", breed, ignore.case = TRUE), "Husky", breed)) |> 
  mutate(breed = ifelse(grepl("chihuahua|chi hua", breed, ignore.case = TRUE), "Chihuahua", breed)) |>
  mutate(breed = ifelse(grepl("collie", breed, ignore.case = TRUE), "Collie", breed)) |> 
  mutate(breed = ifelse(grepl("cattle", breed, ignore.case = TRUE), "Cattle dog", breed)) |> 
  mutate(breed = ifelse(grepl("yorkie|yorkshire", breed, ignore.case = TRUE), "Yorkshire", breed)) |> 
  mutate(breed = ifelse(grepl("schnauzer", breed, ignore.case = TRUE), "Schnauzer", breed)) |> 
  mutate(breed = ifelse(grepl("coonhound", breed, ignore.case = TRUE), "Coonhound", breed)) |> 
  mutate(breed = ifelse(grepl("corgi", breed, ignore.case = TRUE), "Corgie", breed)) |> 
  mutate(breed = ifelse(grepl("dachshund", breed, ignore.case = TRUE), "Dachshund", breed)) |> 
  mutate(breed = ifelse(grepl("beagle", breed, ignore.case = TRUE), "Beagle", breed)) |> 
  mutate(breed = ifelse(grepl("west", breed, ignore.case = TRUE), "Westie", breed)) |> 
  mutate(breed = ifelse(grepl("mastiff", breed, ignore.case = TRUE), "Mastiff", breed)) |> 
  mutate(breed = ifelse(grepl("malti tzu|maltese", breed, ignore.case = TRUE), "Maltese", breed)) |> 
  mutate(breed = ifelse(grepl("shih tzu|Shichon|Shichi", breed, ignore.case = TRUE), "Shih tzu", breed)) |> 
  mutate(breed = ifelse(grepl("parson", breed, ignore.case = TRUE), "Parson", breed)) |> 
  mutate(breed = ifelse(grepl("nova", breed, ignore.case = TRUE), "Nova Scotia Duck Tolling Retriever", breed)) |> 
  mutate(breed = ifelse(grepl("Staffordshire", breed, ignore.case = TRUE), "Staffordshire", breed)) |> 
  mutate(breed = ifelse(grepl("skan mal", breed, ignore.case = TRUE), "alaskan malamute", breed)) |> 
  mutate(breed = ifelse(grepl("russell terr", breed, ignore.case = TRUE), "russell terrier", breed)) |> 
  mutate(breed = ifelse(grepl("shiba", breed, ignore.case = TRUE), "Shiba", breed)) |> 
  mutate(breed = ifelse(grepl("American Terrier", breed, ignore.case = TRUE), "American Terrier", breed)) |> 
  mutate(breed = ifelse(grepl("Golden", breed, ignore.case = TRUE), "Golden Doodle", breed)) |>
  mutate(breed = ifelse(grepl("Springer", breed, ignore.case = TRUE), "Springer", breed)) |> 
  mutate(breed = ifelse(grepl("Catahoula", breed, ignore.case = TRUE), "Catahoula", breed)) |> 
  mutate(breed = ifelse(grepl("Crested", breed, ignore.case = TRUE), "Crested", breed)) |> 
  mutate(breed = ifelse(grepl("Spaniel", breed, ignore.case = TRUE), "Spaniel", breed)) |> 
  mutate(breed = ifelse(grepl("Dandie Dinmont", breed, ignore.case = TRUE), "Dandie Dinmont", breed)) |> 
  mutate(breed = ifelse(grepl("Pug", breed, ignore.case = TRUE), "Puggle", breed)) |> 
  mutate(breed = ifelse(grepl("Potcake", breed, ignore.case = TRUE), "Potcake", breed)) |> 
  mutate(breed = ifelse(grepl("Border Terrier", breed, ignore.case = TRUE), "Border Terrier", breed)) |> 
  mutate(breed = ifelse(grepl("Blue He", breed, ignore.case = TRUE), "Blue Heeler", breed)) |> 
  mutate(breed = ifelse(grepl("Bernedoodle", breed, ignore.case = TRUE), "Bernadoodle", breed)) |> 
  mutate(breed = ifelse(grepl("ne Corso", breed, ignore.case = TRUE), "Caine Corso", breed)) |> 
  mutate(breed = ifelse(grepl("ton De Tulear", breed, ignore.case = TRUE), "Cotton De Tulear", breed)) |> 
  mutate(breed = ifelse(grepl("Daschound|Daschund|Dachshund", breed, ignore.case = TRUE), "Daschund", breed)) |> 
  mutate(breed = ifelse(grepl("Pomsk", breed, ignore.case = TRUE), "Pomski", breed)) |> 
  mutate(breed = ifelse(grepl("Miniature Labradoodle", breed, ignore.case = TRUE), "Mini Labordoodle", breed)) |> 
  mutate(breed = ifelse(grepl("Miniature Pinscher", breed, ignore.case = TRUE), "Mini Pincher", breed)) |> 
  mutate(breed = ifelse(grepl("Wheaten Terrier|wheaton", breed, ignore.case = TRUE), "Wheaton Terrier", breed)) |>
  mutate(breed = ifelse(grepl("Retriever", breed, ignore.case = TRUE), "Retreiver", breed)) |>
  mutate(breed = ifelse(grepl("Dogue De Bord", breed, ignore.case = TRUE), "Dogue De Bordeaux", breed)) |>
  mutate(breed = ifelse(grepl("Medium", breed, ignore.case = TRUE), "Medium", breed)) |>
  mutate(breed = ifelse(grepl("small", breed, ignore.case = TRUE), "small", breed)) |>
  mutate(breed = ifelse(grepl("Wolfhound", breed, ignore.case = TRUE), "Wolfhound", breed)) |>
  mutate(breed = ifelse(grepl("Terrier", breed, ignore.case = TRUE), "Terrier", breed)) |>
  mutate(breed = ifelse(grepl("small", breed, ignore.case = TRUE), "small", breed)) |>
  mutate(breed = str_to_title(breed))

# Dog license
dog_licensing_df = read_csv("data/NYC_Dog_Licensing_Dataset.csv", na = c("NA", "", ".")) |> 
  janitor::clean_names() |> 
  rename_with(~ gsub("^x", "", .))
```

# Variable features
回归使用zipcode中累积的dogbite数量为因变量。


# Negative Binomial Regression Analysis

To measure the combined effects of year, dog background characteristics (i.e., gender and whether neutered) and the Borough they belong to on the incidence of dog bites, we first conduct a negative binomial regression analysis using records of dog bite incidents in New York.

The negative binomial regression model is a type of count model designed for dependent variables that can only take non-negative integer values. From the Spatial Correlations section, the study area meets the three prerequisites for negative binomial regression: the dog bite incidents are not independent, exhibiting spatial clustering; the dependent variable shows overdispersion; and the frequency of dog bite incidents is sufficiently low.

The dependent variable hypothesized in the article is the number of dog bite incidents per zipcode, which follows a negative binomial distribution. The predictor variables include the year and month of the incident, characteristics of the dog, and the area where the incident occurred. The year is measured as an interval-level variable, with values from 1 (corresponding to 2015) to 7 (corresponding to 2021). The area of the incident is divided into variables ranging from 1 to 5, representing the five boroughs of New York City. The gender of the dog is a binary variable, with 1 indicating female and 2 indicating male. Similarly, the sterilization status of the dog is also a binary variable, with 0 indicating unsterilized and 1 indicating sterilized. The model equation is as follows:

$$\ln ({\hat y_i}) = {\beta _0} + {\beta _1}{X_{i1}} + {\beta _2}{X_{i2}} +  \cdots {\beta _m}{X_{im}} + \xi$$
Here, ${y_i}$ represents the frequency of dog bite incidents within a year, ${\beta _m}$ is the coefficient, $X_m$ are the explanatory variables, and $\xi$ represents the heterogeneity across observations.

In negative binomial regression, where the conditional expectation $E(Y|X) = {e^{{\beta _0} + {\beta _1}{X_{i1}} + {\beta _2}{X_{i2}} +  \cdots {\beta _m}{X_{im}}}}$, the interpretation of the model's coefficients is as follows: when the explanatory variable ${X_k}$ increases by one unit, the average occurrence rate of dog bite incidents becomes ${e^{{\beta _k}}}$ times what it was originally.

$$\frac{{E(Y|{X^*})}}{{E(Y|X)}} = \frac{{{e^{{\beta _0} + {\beta _1}{X_{i1}} +  \cdots  + {\beta _k}({X_{ik}} + 1) +  \cdots  + {\beta _m}{X_{im}}}}}}{{{e^{{\beta _0} + {\beta _1}{X_{i1}} +  \cdots  + {\beta _k}{X_{ik}} +  \cdots  + {\beta _m}{X_{im}}}}}} = {e^{{\beta _k}}}$$

### Original Model
```{r}
library(MASS)

dog_bites_filtered = dog_bites_clean %>%
  filter(gender != "U",
         zip_code %in% valid_zipcodes,
         borough != "Other") %>%
  mutate(
    gender = factor(gender),
    spay_neuter = factor(spay_neuter, levels = c(FALSE, TRUE), labels = c("Not Neutered", "Neutered")),
    borough = factor(borough),
    year = factor(year),
    month = factor(month)
  )

bites_by_group = dog_bites_filtered %>%
  count(year, month, gender, spay_neuter, borough, name = "bite_count")

model = glm.nb(bite_count ~ year + month + gender + spay_neuter + borough, data = bites_by_group)

summary(model)
```

### With Interaction

```{r, warning=FALSE, message=FALSE, include=FALSE}
model_all_interactions <- glm.nb(
  formula = bite_count ~ 
    year + month + gender + spay_neuter + borough +
    year * month + year * gender + year * spay_neuter + year * borough +
    month * gender + month * spay_neuter + month * borough +
    gender * spay_neuter + gender * borough + spay_neuter * borough +
    year * month * gender + year * month * spay_neuter + year * month * borough + 
    year * gender * spay_neuter + year * gender * borough + year * spay_neuter * borough +
    month * gender * spay_neuter + month * gender * borough + month * spay_neuter * borough +
    gender * spay_neuter * borough +
    year * month * gender * spay_neuter + year * month * gender * borough +
    year * month * spay_neuter * borough + year * gender * spay_neuter * borough +
    month * gender * spay_neuter * borough,
  data = bites_by_group
)

model_stepwise <- stepAIC(model_all_interactions, direction = "both")
```

```{r}
filter_model = glm.nb(bite_count ~ year + month + gender + spay_neuter + 
    borough + year:spay_neuter + year:borough + month:spay_neuter + 
    gender:spay_neuter + gender:borough + spay_neuter:borough, 
    data = bites_by_group)

summary(filter_model)
```

### Model evaluation
```{r}
# Predicted vs Actual Bite Count
inter_predict = bites_by_group |> 
  mutate(predicted = predict(model_stepwise, type = "response"))

ggplot(inter_predict, aes(x = predicted, y = bite_count)) +
  geom_point(alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, color = "red", linetype = "dashed") +
  labs(title = "Predicted vs. Actual Bite Count",
       x = "Predicted Bite Count",
       y = "Actual Bite Count") +
  theme_minimal()
```


```{r}
library(DHARMa)
residuals_sim = simulateResiduals(model_stepwise)
plot(model_stepwise)
```

# Regularized Model (Lasso)

```{r, warning=FALSE}
# lasso
library(glmnet)

# 将数据转换为矩阵
x = model.matrix(bite_count ~ year + month + gender + spay_neuter + borough, data = bites_by_group)
y = bites_by_group |> pull(bite_count)

# Lasso 回归
cv_model = cv.glmnet(x, y, family = "poisson", alpha = 1)  # Lasso：alpha = 1
summary(cv_model)

cv_results <- data.frame(
  log_lambda = log(cv_model$lambda),
  mean_mse = cv_model$cvm,
  lower_mse = cv_model$cvlo,
  upper_mse = cv_model$cvup
)

best_lambda <- cv_model$lambda.min
log_best_lambda <- log(best_lambda)

ggplot(cv_results, aes(x = log_lambda, y = mean_mse)) +
  geom_line(color = "blue", size = 1) +
  geom_ribbon(aes(ymin = lower_mse, ymax = upper_mse), alpha = 0.2, fill = "blue") +
  geom_vline(xintercept = log_best_lambda, linetype = "dashed", color = "red") +
  labs(
    title = "Cross-Validation for Lasso Regression",
    x = "Log(Lambda)",
    y = "Mean Cross-Validated Error"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# 获取模型在最佳 lambda 下的系数
lasso_coefficients <- coef(cv_model, s = "lambda.min")

# 将系数转换为数据框以便查看
lasso_coefficients_df <- as.data.frame(as.matrix(lasso_coefficients)) %>%
  rownames_to_column("Variable") %>%
  rename(Coefficient = 1) %>%
  filter(Coefficient != 0)  # 筛选非零系数的变量

print(lasso_coefficients_df)

```

* 使用Lasso回归的结果进行预测
```{r}
final_model <- glmnet(x, y, family = "poisson", alpha = 1, lambda = best_lambda)
final_model
#predictions_lasso <- bites_by_group |> mutate(predicted = predict(final_model, type = "response"))
```



# Generalized Linear Mixed Model (GLMM)

另一方面，本文进一步使用Generalized Linear Mixed Model (GLMM)验证所得的回归结果。

The Generalized Linear Mixed Model (GLMM) is an extension of the Generalized Linear Model (GLM) and the Linear Mixed Model (LMM). GLMM consists of three main components: random effects, fixed effects, and a link function. Fixed effects represent the overall level parameters consistent across all observations, while random effects account for individual variability or group-level differences that may influence the response variable. The link function connects the linear predictor to the mean of the response variable distribution, allowing the dependent variable to deviate from a normal distribution and enabling modeling of various types of data, including binary, count, and continuous outcomes.


Let the response variable $y$ belongs to the exponential family, its conditional distribution can be expressed as follows:

$$f(y|b) = \prod\limits_{i = 1}^n {f({y_i}|{\eta _i})}$$

Where ${\eta _i} = {x_i}^ \top \beta  + {z_i}^ \top b$. Additionally, the random effect $b$ is assumed to be distributed according to $b \sim {\rm N}(0,\Sigma )$.

Therefore the GLMM is structured as follows:

$$g(\vec {\rm E}(y)) = {\rm X}\vec \beta  + {\rm Z}\vec b + \varepsilon$$

In the model, $g( \cdot )$ represents the link function, which connects the expected value of the response variable to the linear predictor. Here, the logarithm function $g(\mu ) = \ln (\mu )$ is used, which is appropriate for the Poisson distribution. $\vec{\mathrm{E}}(y)$ denotes the vector of expected values for the response variable, and $\varepsilon$ represents the error term, capturing random noise or the unexplained variance. ${\rm X}\vec \beta  + {\rm Z}\vec b$ represents the linear combination of fixed and random effects, ${\rm X}\vec \beta$ is used to explain global trends, and ${\rm Z}\vec b$ is utilized to capture differences among observations. In this context, ${\rm X}$ is the design matrix for fixed effects, which is of order $n \times p$, where $n$ is the number of observations and $p$ is the number of fixed effect variables; $\vec \beta$ is the vector of coefficients for fixed effects, with each element representing the regression coefficient of a fixed effect variable. Similarly, ${\rm Z}$ also serves as the design matrix for random effects, of order $n \times q$, where $q$ is the number of random effect variables. $\vec b$ is the vector of coefficients for random effects, representing inter-group deviations used to explain random differences between groups. The model assumes $b \sim {\rm N}(0,\Sigma )$, thereby the random effects are normally distributed with a mean of $0$ and a covariance matrix $\Sigma$.

对于狗咬伤事件数据集，响应变量$y$为每月每zipcode的事件的发生，固定效应包括温度和湿度。随机效应为不同实验员（10 个实验员）。因此，对于所有响应变量，${\rm X}$是包含年份，月份，地区，性别，绝育状态的矩阵；$\vec \beta$为固定效应系数；${\rm X}$表示每个响应变量所属品种的矩阵；$\vec b$为每个品种的偏差值（随机效应）。

=======


```{r, warning=FALSE, message=FALSE}
library(lme4)
glmm_model = glmer.nb(
  bite_count ~ year + month + gender + spay_neuter + (1 | borough), 
  data = bites_by_group
)
summary(glmm_model)
```


# Model 
>>>>>>> 6e0a48bc06a0411fc9c5ffd605c67fd4cbef063b

# Conclusion